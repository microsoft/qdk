// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

use enum_iterator::Sequence;
use std::str::FromStr;

#[derive(Clone, Copy, Debug, Eq, Hash, PartialEq, Sequence)]
pub(crate) enum Keyword {
    Adj,
    Adjoint,
    AdjointUpper,
    And,
    Apply,
    As,
    Auto,
    BigInt,
    Body,
    Bool,
    Borrow,
    Controlled,
    ControlledUpper,
    Ctl,
    Distribute,
    Double,
    Elif,
    Else,
    Fail,
    False,
    Fixup,
    For,
    Function,
    If,
    In,
    Int,
    Internal,
    Intrinsic,
    Invert,
    Is,
    Let,
    Mutable,
    Namespace,
    Newtype,
    Not,
    One,
    Open,
    Operation,
    Or,
    Pauli,
    PauliI,
    PauliX,
    PauliY,
    PauliZ,
    Qubit,
    Range,
    Repeat,
    Result,
    Return,
    Slf,
    Set,
    String,
    True,
    Underscore,
    Unit,
    Until,
    Use,
    While,
    Within,
    Zero,
}

impl Keyword {
    pub(super) fn as_str(self) -> &'static str {
        match self {
            Self::Adj => "Adj",
            Self::Adjoint => "adjoint",
            Self::AdjointUpper => "Adjoint",
            Self::And => "and",
            Self::Apply => "apply",
            Self::As => "as",
            Self::Auto => "auto",
            Self::BigInt => "BigInt",
            Self::Body => "body",
            Self::Bool => "Bool",
            Self::Borrow => "borrow",
            Self::Controlled => "controlled",
            Self::ControlledUpper => "Controlled",
            Self::Ctl => "Ctl",
            Self::Distribute => "distribute",
            Self::Double => "Double",
            Self::Elif => "elif",
            Self::Else => "else",
            Self::Fail => "fail",
            Self::False => "false",
            Self::Fixup => "fixup",
            Self::For => "for",
            Self::Function => "function",
            Self::If => "if",
            Self::In => "in",
            Self::Int => "Int",
            Self::Internal => "internal",
            Self::Intrinsic => "intrinsic",
            Self::Invert => "invert",
            Self::Is => "is",
            Self::Let => "let",
            Self::Mutable => "mutable",
            Self::Namespace => "namespace",
            Self::Newtype => "newtype",
            Self::Not => "not",
            Self::One => "One",
            Self::Open => "open",
            Self::Operation => "operation",
            Self::Or => "or",
            Self::Pauli => "Pauli",
            Self::PauliI => "PauliI",
            Self::PauliX => "PauliX",
            Self::PauliY => "PauliY",
            Self::PauliZ => "PauliZ",
            Self::Qubit => "Qubit",
            Self::Range => "Range",
            Self::Repeat => "repeat",
            Self::Result => "Result",
            Self::Return => "return",
            Self::Slf => "self",
            Self::Set => "set",
            Self::String => "String",
            Self::True => "true",
            Self::Underscore => "_",
            Self::Unit => "Unit",
            Self::Until => "until",
            Self::Use => "use",
            Self::While => "while",
            Self::Within => "within",
            Self::Zero => "Zero",
        }
    }
}

impl FromStr for Keyword {
    type Err = ();

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "Adj" => Ok(Self::Adj),
            "adjoint" => Ok(Self::Adjoint),
            "Adjoint" => Ok(Self::AdjointUpper),
            "and" => Ok(Self::And),
            "apply" => Ok(Self::Apply),
            "as" => Ok(Self::As),
            "auto" => Ok(Self::Auto),
            "BigInt" => Ok(Self::BigInt),
            "body" => Ok(Self::Body),
            "Bool" => Ok(Self::Bool),
            "borrow" => Ok(Self::Borrow),
            "controlled" => Ok(Self::Controlled),
            "Controlled" => Ok(Self::ControlledUpper),
            "Ctl" => Ok(Self::Ctl),
            "distribute" => Ok(Self::Distribute),
            "Double" => Ok(Self::Double),
            "elif" => Ok(Self::Elif),
            "else" => Ok(Self::Else),
            "fail" => Ok(Self::Fail),
            "false" => Ok(Self::False),
            "fixup" => Ok(Self::Fixup),
            "for" => Ok(Self::For),
            "function" => Ok(Self::Function),
            "if" => Ok(Self::If),
            "in" => Ok(Self::In),
            "Int" => Ok(Self::Int),
            "internal" => Ok(Self::Internal),
            "intrinsic" => Ok(Self::Intrinsic),
            "invert" => Ok(Self::Invert),
            "is" => Ok(Self::Is),
            "let" => Ok(Self::Let),
            "mutable" => Ok(Self::Mutable),
            "namespace" => Ok(Self::Namespace),
            "newtype" => Ok(Self::Newtype),
            "not" => Ok(Self::Not),
            "One" => Ok(Self::One),
            "open" => Ok(Self::Open),
            "operation" => Ok(Self::Operation),
            "or" => Ok(Self::Or),
            "Pauli" => Ok(Self::Pauli),
            "PauliI" => Ok(Self::PauliI),
            "PauliX" => Ok(Self::PauliX),
            "PauliY" => Ok(Self::PauliY),
            "PauliZ" => Ok(Self::PauliZ),
            "Qubit" => Ok(Self::Qubit),
            "Range" => Ok(Self::Range),
            "repeat" => Ok(Self::Repeat),
            "Result" => Ok(Self::Result),
            "return" => Ok(Self::Return),
            "self" => Ok(Self::Slf),
            "set" => Ok(Self::Set),
            "String" => Ok(Self::String),
            "true" => Ok(Self::True),
            "_" => Ok(Self::Underscore),
            "Unit" => Ok(Self::Unit),
            "until" => Ok(Self::Until),
            "use" => Ok(Self::Use),
            "while" => Ok(Self::While),
            "within" => Ok(Self::Within),
            "Zero" => Ok(Self::Zero),
            _ => Err(()),
        }
    }
}
