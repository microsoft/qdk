name: qsharp-publish-$(BuildId)

# Run on merges to main to ensure that the latest code
# is always able to be published.
trigger:
  branches:
    include:
    - main

# Run the pipeline every day at 6:00 AM to ensure
# codeql and other governance checks are up-to-date.
schedules:
- cron: "0 6 * * *"
  displayName: 'Build for Component Governance'
  branches:
    include:
    - main
  always: true

variables:
  CARGO_TERM_COLOR: always
  RUST_TOOLCHAIN_VERSION: "1.84"

resources:
  repositories:
  - repository: 1ESPipelineTemplates
    type: git
    name: 1ESPipelineTemplates/1ESPipelineTemplates
    ref: refs/tags/release

parameters:
- name: matrix
  type: object
  default:
  - name: linux_x86_64
    poolName: 'Azure-Pipelines-DevTools-EO'
    imageName: 'ubuntu-22.04'
    os: linux
    arch: x86_64
    additionalTargets: wasm32-unknown-unknown
  - name: linux_aarch64
    poolName: 'Azure-Pipelines-DevTools-ARM64-EO'
    imageName: 'mariner-2.0-arm64'
    os: linux
    arch: aarch64
    additionalRustTargets: wasm32-unknown-unknown
  - name: mac_universal
    poolName: 'Azure Pipelines'
    imageName: 'macOS-latest'       # MacOS-specific Py (Mac is usually quite limited).
    os: macOS
    arch: x86_64
    additionalRustTargets: aarch64-apple-darwin wasm32-unknown-unknown
  - name: windows_x86_64
    poolName: 'Azure-Pipelines-DevTools-EO'
    imageName: 'windows-latest'     # Win-specific Py + Platform-independent Py.
    os: windows
    arch: x86_64
    additionalTargets: wasm32-unknown-unknown
  - name: windows_aarch64
    poolName: 'Azure-Pipelines-DevTools-ARM64-EO'
    imageName: 'Windows-2022-ARM64'     # Win-specific Py + Platform-independent Py.
    os: windows
    arch: aarch64
    additionalRustTargets: wasm32-unknown-unknown


# variables set by pipeline
# - BASE_IMAGE
# - BUILD_NUMBER
# - BUILD_TYPE
# - cratesIoFeedOverride
# - OwnerPersonalAlias
# - PAT
# - toolchainFeed

extends:
  template: v1/1ES.Official.PipelineTemplate.yml@1ESPipelineTemplates
  parameters:
    sdl:
      sourceAnalysisPool:
        name: 'Azure-Pipelines-DevTools-EO'
        image: windows-2022
        os: windows
    stages:
    - stage: build
      displayName: Build
      jobs:
      - job: "Node"
        pool:
          name: 'Azure-Pipelines-DevTools-EO'
          image: 'ubuntu-latest'
          os: linux
        timeoutInMinutes: 90
        templateContext:
          outputs:
          - output: pipelineArtifact
            displayName: 'Upload NPM Package Artifact'
            targetPath: $(System.DefaultWorkingDirectory)/target/npm/qsharp
            artifactName: NPM
            condition: succeeded()
        steps:
          # common init steps
          - task: RustInstaller@1
            inputs:
              rustVersion: ms-$(RUST_TOOLCHAIN_VERSION)
              additionalTargets: wasm32-unknown-unknown
              cratesIoFeedOverride: $(cratesIoFeedOverride)
              toolchainFeed: $(toolchainFeed)
            displayName: Install Rust toolchain

          - task: UsePythonVersion@0
            inputs:
              versionSpec: '3.11'

          - task: UseNode@1
            inputs:
              version: "20.x"

          - script: |
              python ./prereqs.py --install && python ./version.py
            displayName: Install Prereqs and set version

          # build steps

          - script: |
              python build.py --npm --wasm --no-check-prereqs
            displayName: Build VSCode Extension

          - script: |
              mkdir -p $(System.DefaultWorkingDirectory)/target/npm/qsharp
              npm pack --pack-destination $(System.DefaultWorkingDirectory)/target/npm/qsharp
            displayName: Pack NPM Package
            workingDirectory: $(System.DefaultWorkingDirectory)/npm/qsharp

      - job: "VSCode"
        pool:
          name: 'Azure-Pipelines-DevTools-EO'
          image: 'ubuntu-latest'
          os: linux
        timeoutInMinutes: 90
        templateContext:
          outputs:
          - output: pipelineArtifact
            displayName: 'Upload VSCode Extension Artifact'
            targetPath: $(System.DefaultWorkingDirectory)/target/vscode
            artifactName: VSIX
            condition: succeeded()
        steps:
        # common init steps
        - task: RustInstaller@1
          inputs:
            rustVersion: ms-$(RUST_TOOLCHAIN_VERSION)
            additionalTargets: wasm32-unknown-unknown
            cratesIoFeedOverride: $(cratesIoFeedOverride)
            toolchainFeed: $(toolchainFeed)
          displayName: Install Rust toolchain

        - task: UsePythonVersion@0
          inputs:
            versionSpec: '3.11'

        - task: UseNode@1
          inputs:
            version: "20.x"

        - script: |
            python ./prereqs.py --install && python ./version.py
          displayName: Install Prereqs and set version

        # Below VS Code extension build only needs to run on one platform (Linux x86_64 for now)
        - script: |
            npm install -g @vscode/vsce
          displayName: Install Prereqs for VSCode Extension

        # build steps

        - script: |
            python build.py --wasm --npm --vscode --integration-tests --no-check-prereqs
          displayName: Build VSCode Extension

        - script: |
            vsce package --pre-release
            mkdir -p $(System.DefaultWorkingDirectory)/target/vscode
            mv *.vsix $(System.DefaultWorkingDirectory)/target/vscode
          condition: and(succeeded(), eq(variables['BUILD_TYPE'], 'dev'))
          displayName: Pack pre-release VSCode Extension
          workingDirectory: '$(System.DefaultWorkingDirectory)/vscode'

        - script: |
            vsce package
            mkdir -p $(System.DefaultWorkingDirectory)/target/vscode
            mv *.vsix $(System.DefaultWorkingDirectory)/target/vscode
          condition: and(succeeded(), ne(variables['BUILD_TYPE'], 'dev'))
          displayName: Pack VSCode Extension
          workingDirectory: '$(System.DefaultWorkingDirectory)/vscode'

      - job: "JupyterLab"
        pool:
          name: 'Azure-Pipelines-DevTools-EO'
          image: 'ubuntu-latest'
          os: linux
        timeoutInMinutes: 90
        templateContext:
          outputs:
          - output: pipelineArtifact
            displayName: 'Upload JupyterLab Python Artifacts'
            targetPath: $(System.DefaultWorkingDirectory)/target/wheels/
            artifactName: Wheels.JupyterLab
            condition: succeeded()
        steps:
        # common init steps
        - task: RustInstaller@1
          inputs:
            rustVersion: ms-$(RUST_TOOLCHAIN_VERSION)
            cratesIoFeedOverride: $(cratesIoFeedOverride)
            toolchainFeed: $(toolchainFeed)
          displayName: Install Rust toolchain

        - task: UsePythonVersion@0
          inputs:
            versionSpec: '3.11'

        - task: UseNode@1
          inputs:
            version: "20.x"

        - script: |
            python ./prereqs.py --skip-wasm && python ./version.py
          displayName: Install Prereqs and set version

        - script: |
            python ./build.py --jupyterlab --widgets --no-check --no-check-prereqs
          displayName: Build JupyterLab Package

        - script: |
            ls target/wheels/*

      - ${{ each target in parameters.matrix }}:
        - job: Python_${{ target.name }}_job
          pool:
            name: ${{ target.poolName }}
            image: ${{ target.imageName }}
            os: ${{ target.os }}
            ${{ if eq(target.arch, 'aarch64') }}:
              hostArchitecture: Arm64
          variables:
            arch: ${{ target.arch }}
            additionalRustTargets: ${{ target.additionalRustTargets }}
          timeoutInMinutes: 90
          templateContext:
            outputs:
            - output: pipelineArtifact
              displayName: 'Upload Python Artifacts Mac'
              condition: and(succeeded(), eq(variables['Agent.OS'], 'Darwin'))
              targetPath: $(System.DefaultWorkingDirectory)/target/wheels
              artifactName: Wheels.Mac
            - output: pipelineArtifact
              displayName: 'Upload Python Artifacts Win'
              condition: and(succeeded(), eq(variables['Agent.OS'], 'Windows_NT'))
              targetPath: $(System.DefaultWorkingDirectory)/target/wheels
              artifactName: Wheels.Win.${{ target.arch }}
            - output: pipelineArtifact
              displayName: 'Upload Python Artifacts Linux'
              condition: and(succeeded(), eq(variables['Agent.OS'], 'Linux'))
              targetPath: $(System.DefaultWorkingDirectory)/target/wheels
              artifactName: Wheels.Linux.${{ target.arch }}
          steps:
          # common init steps
          # if we have additional rust targets, we need to install them
          - task: RustInstaller@1
            inputs:
              rustVersion: ms-$(RUST_TOOLCHAIN_VERSION)
              additionalTargets: $(additionalRustTargets)
              cratesIoFeedOverride: $(cratesIoFeedOverride)
              toolchainFeed: $(toolchainFeed)
            displayName: Install Rust toolchain
            condition: ne(variables['additionalRustTargets'], '')

          # otherwise just install the default toolchain
          - task: RustInstaller@1
            inputs:
              rustVersion: ms-$(RUST_TOOLCHAIN_VERSION)
              cratesIoFeedOverride: $(cratesIoFeedOverride)
              toolchainFeed: $(toolchainFeed)
            displayName: Install Rust toolchain
            condition: eq(variables['additionalRustTargets'], '')

          - script: |
              rustc --version
              rustc --print target-list
            displayName: View rust target info

          # official docs say `UsePythonVersion` only supports x86/x64 for arch
          # but we can set it to arm64 on windows and it will work.
          # we can't do this for linux because they only have ubuntu 20.04/22.04
          # pre-built images for arm64. so we need another way to install python.
          - task: UsePythonVersion@0
            inputs:
              versionSpec: '3.11.9'
              architecture: 'arm64'
            condition: and(eq(variables['Agent.OS'], 'Windows_NT'), eq(variables['arch'], 'aarch64'))

          - task: UsePythonVersion@0
            inputs:
              versionSpec: '3.11'
            condition: ne(variables['arch'], 'aarch64')

          - task: UseNode@1
            inputs:
              version: "20.x"

          # For arm64 windows we need to install the c++ build tools
          - task: PowerShell@2
            inputs:
              targetType: 'inline'
              script: |
                # $paths_to_check = @("C:\vss-agent\4.251.0", "C:\ToolCache", "C:\Program Files (Arm)\", "C:\Program Files (x86)\")
                # foreach ($path in $paths_to_check) {
                #     Write-Host "Checking for $path"
                #     Get-ChildItem -Path $path -Recurse -Filter "*.exe" | ForEach-Object { Write-Host $_.FullName }
                # }
                #Get-ChildItem -Path "C:\Program Files\Microsoft Visual Studio\2022\Enterprise" -Recurse | ForEach-Object { Write-Host $_.FullName }

                # Get all environment variables
                $envVars = Get-ChildItem Env:
                foreach ($envVar in $envVars) {
                    Write-Host "$($envVar.Name) = $($envVar.Value)"
                    $path = "$($envVar.Value)"
                    if(Test-Path $path) {
                        Write-Host "Checking for $path"
                        Get-ChildItem -Path $path -Recurse -Filter "*.exe" | ForEach-Object { Write-Host $_.FullName }
                    }
                }
                # Search for vswhere.exe on the C:\ drive
                # $vswherePath = @(Get-ChildItem -Path C:\ -Filter "vswhere.exe" -Recurse -ErrorAction SilentlyContinue | Select-Object -ExpandProperty FullName)
                # foreach ($path in $vswherePath) {
                #     Write-Host "Found vswhere.exe at: $path"
                # }
                # Search for tools on the C:\ drive
                # only vswhere is found....
                # $tools = @("vs_enterprise.exe", "vs_professional.exe", "vs_community.exe", "vs_buildtools.exe", "vs_installer.exe", "vswhere.exe")
                # foreach ($tool in $tools) {
                #     Write-Host "Searching for $tool on the C:\ drive..."
                #     $path = @(Get-ChildItem -Path C:\ -Filter $tool -Recurse -ErrorAction SilentlyContinue | Select-Object -ExpandProperty FullName)
                #     foreach ($p in $path) {
                #         Write-Host "Found $tool at: $p"
                #     }
                # }
                # Get the path stored in the AGENT_HOMEDIRECTORY environment variable
                # $agentHomeDirectory = $env:AGENT_HOMEDIRECTORY

                # if ($agentHomeDirectory) {
                #     # Search for vswhere.exe in the AGENT_HOMEDIRECTORY directory
                #     $vswherePath = Get-ChildItem -Path $agentHomeDirectory -Filter "vswhere.exe" -Recurse -ErrorAction SilentlyContinue | Select-Object -ExpandProperty FullName

                #     if ($vswherePath) {
                #         Write-Host "Found vswhere.exe at: $vswherePath"
                #         $vs_installer = & $vswherePath -latest -requires Microsoft.VisualStudio.Component.VC.Tools.x86.x64 -find vs_installer.exe
                #         if ($vs_installer) {
                #             & $vs_installer modify --add Microsoft.VisualStudio.Workload.VCTools --add Microsoft.VisualStudio.Component.Windows11SDK.22621 --add Microsoft.VisualStudio.Component.VC.Tools.ARM64 --add Microsoft.VisualStudio.Component.VC.CMake.Project --add Microsoft.VisualStudio.Component.VC.Llvm.Clang --passive --norestart
                #         } else {
                #             Write-Host "vs_installer.exe not found."
                #         }
                #     } else {
                #         Write-Host "vswhere.exe not found in AGENT_HOMEDIRECTORY."
                #     }
                # } else {
                #     Write-Host "AGENT_HOMEDIRECTORY environment variable is not set."
                # }
                # if ($vswherePath) {
                #     Write-Host "Found vswhere.exe at: $vswherePath"
                #     # Check each environment variable as a folder
                #     foreach ($envVar in [System.Environment]::GetEnvironmentVariables().Keys) {
                #         $envPath = [System.Environment]::GetEnvironmentVariable($envVar)
                #         if ($envPath -and (Test-Path $envPath)) {
                #             $fullPath = Join-Path -Path $envPath -ChildPath "vswhere.exe"
                #             if (Test-Path $fullPath) {
                #                 Write-Host "vswhere.exe found in environment variable path: $envVar"
                #             }
                #         }
                #     }
                # } else {
                #     Write-Host "vswhere.exe not found on the C:\ drive."
                # }
                #$vswhere = "${env:ProgramFiles(x86)}\Microsoft Visual Studio\Installer\vswhere.exe"
                #& $vswhere --wait --passive --norestart --add Microsoft.VisualStudio.Workload.VCTools --add Microsoft.VisualStudio.Component.Windows11SDK.22621 --add Microsoft.VisualStudio.Component.VC.Tools.ARM64 --add Microsoft.VisualStudio.Component.VC.CMake.Project --add Microsoft.VisualStudio.Component.VC.Llvm.Clang
            displayName: Install C++ Build Tools on Windows Arm64
            condition: and(eq(variables['Agent.OS'], 'Windows_NT'), eq(variables['arch'], 'aarch64'))

          # on mariner we need to install:
          # ld with binutils
          # crt1.o and others with glibc-devel
          # std lib headers with kernel-headers
          - script: |
              sudo tdnf install binutils glibc-devel kernel-headers -y
            displayName: Install c++ build tools on mariner
            condition: and(eq(variables['Agent.OS'], 'Linux'), eq(variables['arch'], 'aarch64'))

          - script: |
              python ./version.py
            displayName: Set version

          # For arm64 linux(mariner) we need to use the python already installed
          # so we skip the prereqs check
          # For arm64 windows rustup is not present in the image so we need to skip prereqs check too
          - script: |
              python ./prereqs.py --skip-wasm
            displayName: Check Prereqs
            condition: and(not(and(eq(variables['Agent.OS'], 'Linux'), eq(variables['arch'], 'aarch64'))), not(and(eq(variables['Agent.OS'], 'Windows_NT'), eq(variables['arch'], 'aarch64'))))

          - script: |
              python build.py --pip --no-check-prereqs --integration-tests
            displayName: Build Platform-Dependent Py Packages

          - script: |
              # use a venv to make sure the installed tools are on the path
              python -m venv venv
              source venv/bin/activate

              # install tools into the venv
              python -m pip install auditwheel patchelf

              # repair the wheels
              ls target/wheels/*.whl
              for wheel in target/wheels/*.whl; do
                  echo "Processing $wheel"
                  auditwheel show "$wheel"
                  auditwheel repair --wheel-dir ./target/wheels/ --plat manylinux_2_35_${{ target.arch }} "$wheel"
              done
              # remove the original wheels
              rm target/wheels/*-linux_${{ target.arch }}.whl
              # list the wheels for debugging
              ls target/wheels/*.whl
            displayName: Run auditwheel for Linux Wheels
            condition: eq(variables['Agent.OS'], 'Linux')

          - script: |
              dir target\wheels\*
            displayName: List Py Packages on Win
            condition: eq(variables['Agent.OS'], 'Windows_NT')

          - script: |
              ls target/wheels/*
            displayName: List Py Packages on non-Win
            condition: ne(variables['Agent.OS'], 'Windows_NT')

    - stage: approval
      displayName: Approval
      dependsOn: build
      condition: and(succeeded(), eq(variables['Build.Reason'], 'Manual'))
      jobs:
      - job: "Approval"
        pool: server
        timeoutInMinutes: 1440 # job times out in 1 day
        steps:
        - task: ManualValidation@0
          timeoutInMinutes: 1440 # task times out in 1 day
          inputs:
            notifyUsers: ''
            instructions: 'Please verify artifacts and approve the release'
            onTimeout: 'reject'

    - stage: release
      displayName: Release
      dependsOn: approval
      condition: and(succeeded(), eq(variables['Build.Reason'], 'Manual'))
      jobs:
      - job: "Publish_VSIX_Package"
        pool:
          name: 'Azure-Pipelines-DevTools-EO'
          image: 'ubuntu-latest'
          os: linux
        templateContext:
          type: releaseJob
          isProduction: true
          inputs:  # All input build artifacts must be declared here
          - input: pipelineArtifact
            artifactName: VSIX
            targetPath: $(System.DefaultWorkingDirectory)/target/vscode
        steps:
        - script: |
            npm install -g @vscode/vsce
          displayName: Install Prereqs for VSCode Ext Publishing

        - script: |
            VSIX_RPATH="$(System.DefaultWorkingDirectory)/target/vscode"
            VSIX_FNAME=`ls $VSIX_RPATH/*.vsix`
            echo "RPATH: $VSIX_RPATH"
            echo "FNAME: $VSIX_FNAME"
            vsce publish --pre-release --packagePath $VSIX_FNAME 2>&1 > pub.log
          condition: and(succeeded(), eq(variables['BUILD_TYPE'], 'dev'))
          displayName: Publish pre-release VSCode Extension
          env:
            VSCE_PAT: $(PAT)

        - script: |
            VSIX_RPATH="$(System.DefaultWorkingDirectory)/target/vscode"
            VSIX_FNAME=`ls $VSIX_RPATH/*.vsix`
            echo "RPATH: $VSIX_RPATH"
            echo "FNAME: $VSIX_FNAME"
            vsce publish --packagePath $VSIX_FNAME 2>&1 > pub.log
          condition: and(succeeded(), ne(variables['BUILD_TYPE'], 'dev'))
          displayName: Publish VSCode Extension
          env:
            VSCE_PAT: $(PAT)

        - script: |
            dir
            cat pub.log
          displayName: If failed, display VSCode Publishing Results
          condition: failed()
          workingDirectory: '$(System.DefaultWorkingDirectory)'


      # We will get a warning about extra files in the sbom validation saying it failed.
      # This is expected as we have the wheels being downloaded to the same directory.
      # So each successive wheel will have the previous wheel in the directory and each
      # will be flagged as an extra file. See:
      # http://aka.ms/drop-validation-failure-additional-files
      - job: "Publish_Python_Packages"
        pool:
          name: 'Azure-Pipelines-DevTools-EO'
          image: 'ubuntu-latest'
          os: linux
        templateContext:
          type: releaseJob
          isProduction: true
          inputs:  # All input build artifacts must be declared here
          - input: pipelineArtifact
            artifactName: Wheels.Win.x86_64
            targetPath: $(System.DefaultWorkingDirectory)/target/wheels
          - input: pipelineArtifact
            artifactName: Wheels.Win.aarch64
            targetPath: $(System.DefaultWorkingDirectory)/target/wheels
          - input: pipelineArtifact
            artifactName: Wheels.Mac
            targetPath: $(System.DefaultWorkingDirectory)/target/wheels
          - input: pipelineArtifact
            artifactName: Wheels.Linux.x86_64
            targetPath: $(System.DefaultWorkingDirectory)/target/wheels
          - input: pipelineArtifact
            artifactName: Wheels.Linux.aarch64
            targetPath: $(System.DefaultWorkingDirectory)/target/wheels
          - input: pipelineArtifact
            artifactName: Wheels.JupyterLab
            targetPath: $(System.DefaultWorkingDirectory)/target/wheels
        steps:
        - script: |
            ls $(System.DefaultWorkingDirectory)/target/wheels
          displayName: Display Py Artifacts in Publishing Dir

        - task: EsrpRelease@7
          condition: succeeded()
          inputs:
            ConnectedServiceName: 'ESRP Signing Connection'
            KeyVaultName: 'kv-aqua-esrp-001'
            AuthCertName: 'EsrpAuthCert'
            SignCertName: 'EsrpSignCert'
            ClientId: '832c049d-cd07-4c1c-bfa5-c07250d190cb'
            Intent: 'PackageDistribution'
            ContentType: 'PyPi'
            FolderLocation: '$(System.DefaultWorkingDirectory)/target/wheels'
            WaitForReleaseCompletion: true
            Owners: '$(OwnerPersonalAlias)@microsoft.com'  # NB: Group email here fails the task with non-actionable output.
            Approvers: 'billti@microsoft.com'
            # Auto-inserted Debugging defaults:
            ServiceEndpointUrl: 'https://api.esrp.microsoft.com'
            MainPublisher: 'ESRPRELPACMAN'                 # Default ESRP v7 publisher. Do not change.
            DomainTenantId: '72f988bf-86f1-41af-91ab-2d7cd011db47'
          displayName: Publish Py Packages


      - job: "Publish_NPM_Package"
        pool:
          name: 'Azure-Pipelines-DevTools-EO'
          image: 'ubuntu-latest'
          os: linux
        templateContext:
          type: releaseJob
          isProduction: true
          inputs:  # All input build artifacts must be declared here
          - input: pipelineArtifact
            artifactName: NPM
            targetPath: $(System.DefaultWorkingDirectory)/target/npm/qsharp
        steps:
        - script: |
            ls $(System.DefaultWorkingDirectory)/target/npm/qsharp/*
          displayName: Display NPM Artifacts in Publishing Dir

        - task: EsrpRelease@7
          condition: succeeded()
          inputs:
            ConnectedServiceName: 'ESRP Signing Connection'
            KeyVaultName: 'kv-aqua-esrp-001'
            AuthCertName: 'EsrpAuthCert'
            SignCertName: 'EsrpSignCert'
            ClientId: '832c049d-cd07-4c1c-bfa5-c07250d190cb'
            Intent: 'PackageDistribution'
            ContentType: 'NPM'
            FolderLocation: '$(System.DefaultWorkingDirectory)/target/npm/qsharp'
            WaitForReleaseCompletion: true
            Owners: '$(OwnerPersonalAlias)@microsoft.com'  # NB: Group email here fails the task with non-actionable output.
            Approvers: 'billti@microsoft.com'
            # Auto-inserted Debugging defaults:
            ServiceEndpointUrl: 'https://api.esrp.microsoft.com'
            MainPublisher: 'ESRPRELPACMAN'                 # Default ESRP v7 publisher. Do not change.
            DomainTenantId: '72f988bf-86f1-41af-91ab-2d7cd011db47'
          displayName: Publish NPM Package
