// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

#[cfg(test)]
mod tests;

use crate::display::increase_header_level;
use crate::{compilation::Compilation, display::CodeDisplay};
use qsc::hir::hir::{Item, ItemKind, Package, Visibility};
use qsc::hir::ty::Udt;
use qsc::hir::{CallableDecl, Ident};
use rustc_hash::FxHashMap;
use std::fs;
use std::rc::Rc;

// Warning: this path gets deleted on each run. Use carefully!
const GENERATED_DOCS_PATH: &str = "../generated_docs";

pub(crate) fn generate_docs(compilation: &Compilation) {
    let display = &CodeDisplay { compilation };

    delete_existing_docs();
    fs::create_dir(GENERATED_DOCS_PATH).expect("Unable to create directory for generated docs");

    let mut toc: FxHashMap<Rc<str>, Vec<String>> = FxHashMap::default();
    for (_, unit) in &compilation.package_store {
        let package = &unit.package;
        for (_, item) in &package.items {
            if let Some((ns, line)) = generate_doc_for_item(package, item, display) {
                toc.entry(ns).or_default().push(line);
            }
        }
    }

    generate_toc(&toc);
}

fn delete_existing_docs() {
    // Checks if the generated docs exist
    if fs::metadata(GENERATED_DOCS_PATH).is_ok() {
        // Warning, use this carefully!
        fs::remove_dir_all(GENERATED_DOCS_PATH).expect("Unable to remove existing docs");
    }
}

fn generate_doc_for_item<'a>(
    package: &'a Package,
    item: &'a Item,
    display: &'a CodeDisplay,
) -> Option<(Rc<str>, String)> {
    // Filter items
    if item.visibility == Visibility::Internal || matches!(item.kind, ItemKind::Namespace(_, _)) {
        return None;
    }

    // Get namespace for item
    let ns = get_namespace(package, item)?;

    // Create ns folder, if it doesn't exist
    let ns_dir = format!("{GENERATED_DOCS_PATH}/{ns}");
    if fs::metadata(&ns_dir).is_err() {
        fs::create_dir(&ns_dir).expect("Unable to create directory for namespace");
    }

    // Print file
    let (title, content) = item_to_content(package, item, display)?;
    fs::write(format!("{ns_dir}/{title}.md"), content).expect("Unable to write file");

    // Create toc line
    let line = format!("  - {{name: {title}, uid: {ns}.{title}}}");

    // Return (ns, line)
    Some((ns.clone(), line))
}

fn get_namespace(package: &Package, item: &Item) -> Option<Rc<str>> {
    match item.parent {
        Some(local_id) => {
            let parent = package
                .items
                .get(local_id)
                .expect("Could not resolve parent item id");
            match &parent.kind {
                ItemKind::Namespace(name, _) => {
                    if name.name.starts_with("QIR") {
                        None // We ignore "QIR" namespaces
                    } else {
                        Some(name.name.clone())
                    }
                }
                _ => None,
            }
        }
        None => None,
    }
}

fn item_to_content(
    package: &Package,
    item: &Item,
    display: &CodeDisplay,
) -> Option<(String, String)> {
    match &item.kind {
        ItemKind::Callable(decl) => Some((
            decl.name.name.to_string(),
            callable_to_content(decl, &item.doc, display),
        )),
        ItemKind::Ty(name, udt) => Some((
            name.name.to_string(),
            udt_to_content(name, udt, &item.doc, display),
        )),
        ItemKind::Namespace(_, _) => None,
    }
}

fn callable_to_content(decl: &CallableDecl, doc: &str, display: &CodeDisplay) -> String {
    if doc.is_empty() {
        format!(
            "# {} {}\n\n`{}`\n",
            decl.name.name,
            decl.kind,
            display.hir_callable_decl(decl)
        )
    } else {
        let doc = increase_header_level(doc);
        format!(
            "# {} {}\n\n`{}`\n\n{}\n",
            decl.name.name,
            decl.kind,
            display.hir_callable_decl(decl),
            doc
        )
    }
}

fn udt_to_content(name: &Ident, udt: &Udt, doc: &str, display: &CodeDisplay) -> String {
    if doc.is_empty() {
        format!(
            "# {} User-Defined Type\n\n`{}`\n",
            name.name,
            display.hir_udt(udt)
        )
    } else {
        let doc = increase_header_level(doc);
        format!(
            "# {} User-Defined Type\n\n`{}`\n\n{}\n",
            name.name,
            display.hir_udt(udt),
            doc
        )
    }
}

fn generate_toc(map: &FxHashMap<Rc<str>, Vec<String>>) {
    let header = "
# This file is automatically generated.
# Please do not modify this file manually, or your changes may be lost when
# documentation is rebuilt.";
    let table = map
        .iter()
        .map(|(namespace, lines)| {
            let items_str = lines.join("\n");
            format!("- items:\n{items_str}\n  name: {namespace}\n  uid: {namespace}")
        })
        .collect::<Vec<_>>()
        .join("\n");
    let contents = format!("{header}\n{table}");

    fs::write(format!("{GENERATED_DOCS_PATH}/toc.yml"), contents)
        .expect("Unable to create table of contents file");
}
