// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

import { useEffect, useRef, useState } from "preact/hooks";
import { Spinner } from "./spinner.js";

// This component is shared by the Python widget and the VS Code panel
export function Flamegraph(props: { stacks: IStacks }) {
  const stacks = props.stacks;

  return (
    <div>
      <ZoomableCircuit {...props} stacks={stacks} />
    </div>
  );
}

function ZoomableCircuit(props: { stacks: IStacks }) {
  const circuitDiv = useRef<HTMLDivElement>(null);
  const [zoomLevel, setZoomLevel] = useState(100);
  const [rendering, setRendering] = useState(true);
  const [zoomOnResize, setZoomOnResize] = useState(true);

  useEffect(() => {
    // Enable "rendering" text while the circuit is being drawn
    setRendering(true);
    const container = circuitDiv.current!;
    container.innerHTML = "";
  }, [props.stacks]);

  useEffect(() => {
    if (rendering) {
      const container = circuitDiv.current!;
      // Draw the circuits - may take a while for large circuits
      const svg = renderFlamegraph(props.stacks, container);

      const initialZoom = calculateZoomToFit(container, svg as SVGElement);
      // Set the initial zoom level
      setZoomLevel(initialZoom);
      // Resize the SVG to fit
      updateWidth();

      // Calculate the initial zoom level based on the container width
      // Disable "rendering" text
      setRendering(false);
    } else {
      // Initial drawing done, attach window resize handler
      window.addEventListener("resize", onResize);
      return () => {
        window.removeEventListener("resize", onResize);
      };
    }
  }, [rendering, zoomOnResize]);

  useEffect(() => {
    updateWidth();
  }, [zoomLevel]);

  return (
    <div>
      <div>
        {rendering ? null : (
          <ZoomControl zoom={zoomLevel} onInput={userSetZoomLevel} />
        )}
      </div>
      <div>{rendering ? `Rendering flamegraph...` : ""}</div>
      <div
        class="qs-circuit"
        id="qs-flamegraph-container"
        ref={circuitDiv}
      ></div>
    </div>
  );

  /**
   * Window resize handler to recalculate and set the zoom level
   * based on the new window width.
   */
  function onResize() {
    if (!zoomOnResize) {
      return;
    }

    const [container, svg] = [circuitDiv.current, currentSvg()];
    if (container && svg) {
      // Recalculate the zoom level based on the container width
      const initialZoom = calculateZoomToFit(container, svg);
      // Set the zoom level
      setZoomLevel(initialZoom);
    }
  }

  /**
   * Update the width of the SVG element based on the current zoom level.
   */
  function updateWidth() {
    const svg = currentSvg();
    if (svg) {
      // The width attribute contains the true width, generated by qviz.
      // We'll leave this attribute untouched, so we can use it again if the
      // zoom level is ever updated.
      const width = svg.getAttribute("width")!;

      // We'll set the width in the style attribute to (true width * zoom level).
      // This value takes precedence over the true width in the width attribute.
      svg.setAttribute(
        "style",
        `max-width: ${width}; width: ${(parseInt(width) * (zoomLevel || 100)) / 100}; height: auto`,
      );
    }
  }

  // function renderFlamegraph_(stacks: IStacks, container: HTMLDivElement) {
  //   // render a svg element into the container. for now, the svg just contains
  //   // a pre element with the JSON serialization of the stacks.

  //   // First, create a temporary pre element to measure its natural size
  //   const tempPre = document.createElement("pre");
  //   tempPre.innerHTML = JSON.stringify(stacks, null, 2);
  //   tempPre.style.position = "absolute";
  //   tempPre.style.visibility = "hidden";
  //   document.body.appendChild(tempPre);

  //   const width = tempPre.offsetWidth;
  //   const height = tempPre.offsetHeight;
  //   document.body.removeChild(tempPre);

  //   // Now create the SVG with the measured dimensions
  //   const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
  //   svg.setAttribute("width", width.toString());
  //   svg.setAttribute("height", height.toString());
  //   svg.classList.add("flamegraph-svg");

  //   // Use foreignObject to embed the pre element in the SVG
  //   const foreignObject = document.createElementNS(
  //     "http://www.w3.org/2000/svg",
  //     "foreignObject",
  //   );
  //   foreignObject.setAttribute("width", width.toString());
  //   foreignObject.setAttribute("height", height.toString());

  //   const pre = document.createElement("pre");
  //   pre.innerHTML = JSON.stringify(stacks, null, 2);
  //   foreignObject.appendChild(pre);
  //   svg.appendChild(foreignObject);

  //   container.appendChild(svg);

  //   return svg;
  // }

  function renderFlamegraph(stacks: IStacks, container: HTMLDivElement) {
    // @ts-expect-error - flamegraph is a global variable
    const chart = flamegraph()
      .width(960)
      .label(function (d: any) {
        console.log("d", d);
        return `${d.data.name} (${d.data.value})`;
      });

    // const data = await d3.json("data.json");
    // @ts-expect-error - d3 is a global variable
    d3.select("#qs-flamegraph-container").datum(stacks).call(chart);
    console.log("sure did something");

    return container.getElementsByClassName("d3-flame-graph")[0]!;
  }

  /**
   * Calculate the zoom level that will fit the circuit into the current size of the container.
   */
  function calculateZoomToFit(container: HTMLDivElement, svg: SVGElement) {
    const containerWidth = container.clientWidth;
    // width and height are the true dimensions generated by qviz
    const width = parseInt(svg.getAttribute("width")!);
    const height = svg.getAttribute("height")!;

    svg.setAttribute("viewBox", `0 0 ${width} ${height}`);
    const zoom = Math.min(Math.ceil((containerWidth / width) * 100), 100);
    return zoom;
  }

  function currentSvg(): SVGElement | undefined {
    return circuitDiv.current?.querySelector(".d3-flame-graph") ?? undefined;
  }

  function userSetZoomLevel(zoom: number) {
    setZoomOnResize(false);
    setZoomLevel(zoom);
  }
}

function ZoomControl(props: { zoom: number; onInput: (zoom: number) => void }) {
  return (
    <p>
      <label htmlFor="qs-circuit-zoom">Zoom </label>
      <input
        id="qs-circuit-zoom"
        type="number"
        min="10"
        max="100"
        step="10"
        value={props.zoom}
        onInput={(e) =>
          props.onInput(parseInt((e.target as HTMLInputElement).value) || 0)
        }
      />
      %
    </p>
  );
}

// This component is exclusive to the VS Code panel
export function FlamegraphPanel(props: FlamegraphProps) {
  const error = props.errorHtml ? (
    <div>
      <p>
        {props.stacks
          ? "The program encountered a failure. See the error(s) below."
          : "A circuit could not be generated for this program. See the error(s) below."}
        <br />
      </p>
      <div dangerouslySetInnerHTML={{ __html: props.errorHtml }}></div>
    </div>
  ) : null;

  return (
    <div class="qs-circuit-panel">
      <div>
        <h1>
          {props.title} {props.simulated ? "(Trace)" : ""}
        </h1>
      </div>
      {error && <div class="qs-circuit-error">{error}</div>}
      {props.targetProfile && <p>{props.targetProfile}</p>}
      {props.simulated && (
        <p>
          WARNING: This diagram shows the result of tracing a dynamic circuit,
          and may change from run to run.
        </p>
      )}
      {props.calculating ? (
        <div>
          <Spinner />
        </div>
      ) : null}
      {props.stacks ? <Flamegraph stacks={props.stacks}></Flamegraph> : null}
    </div>
  );
}

type FlamegraphProps = {
  title: string;
  stacks?: IStacks;
  errorHtml?: string;
  targetProfile: string;
  /** Trace was generated by running the simulator */
  simulated: boolean;
  /** Trace is still being generated */
  calculating: boolean;
};
interface IStacks {
  name: string;
  value: number;
  children: IStacks[];
}
