// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

use crate::{CircuitTracer, TracerConfig, builder::tests::FakeCompilation};
use expect_test::{Expect, expect};
use qsc_eval::backend::Tracer;

fn check(instructions: &'static [(&'static [(&'static str, u32)], &'static str)], expect: &Expect) {
    let mut tracer = CircuitTracer::new(
        TracerConfig {
            max_operations: usize::MAX,
            source_locations: false,
            group_scopes: true,
            loop_detection: false,
            collapse_qubit_registers: false,
        },
        &FakeCompilation::user_package_ids(),
    );
    let mut c = FakeCompilation::default();

    let qubit_id = 0;

    // Allocate qubit 0
    tracer.qubit_allocate(&[], qubit_id);

    // Trace each instruction, applying it to qubit 0
    for i in instructions {
        let stack =
            i.0.iter()
                .map(|(scope, offset)| c.user_code_frame(scope, *offset))
                .collect::<Vec<_>>();
        let name = i.1;

        tracer.gate(&stack, name, false, &[qubit_id], &[], None);
    }

    let circuit = tracer.finish(&c);
    expect.assert_eq(&circuit.to_string());
}

#[test]
fn empty() {
    // TODO: we disabled source labels in these tests, these shouldn't show up
    check(
        &[],
        &expect![[r#"
            q_0
        "#]],
    );
}

#[test]
fn single_op_no_metadata() {
    check(
        &[(&[], "H")],
        &expect![[r#"
        q_0    ── H ──
    "#]],
    );
}

#[test]
fn single_op() {
    check(
        &[(&[("Main", 1)], "H")],
        &expect![[r#"
                      ┌──── [Main] ─────┐
            q_0    ───┼─────── H ───────┼───
                      └─────────────────┘
        "#]],
    );
}

#[test]
fn two_ops_in_same_scope() {
    check(
        &[(&[("Main", 1)], "H"), (&[("Main", 2)], "X")],
        &expect![[r#"
                      ┌──── [Main] ────────────┐
            q_0    ───┼─────── H ────── X ─────┼───
                      └────────────────────────┘
        "#]],
    );
}

#[test]
fn two_ops_in_separate_scopes() {
    check(
        &[(&[("Foo", 1)], "H"), (&[("Bar", 2)], "X")],
        &expect![[r#"
                      ┌──── [Foo] ────┐      ┌──── [Bar] ────┐
            q_0    ───┼────── H ──────┼──────┼────── X ──────┼───
                      └───────────────┘      └───────────────┘
        "#]],
    );
}

#[test]
fn two_ops_same_grandparent() {
    check(
        &[
            (&[("Main", 1), ("Foo", 2)], "H"),
            (&[("Main", 1), ("Bar", 3)], "X"),
        ],
        &expect![[r#"
                      ┌──── [Main] ────────────────────────────────────────────┐
                      │        ┌────── [Foo] ────┐      ┌──── [Bar] ────┐      │
            q_0    ───┼────────┼──────── H ──────┼──────┼────── X ──────┼──────┼───
                      │        └─────────────────┘      └───────────────┘      │
                      └────────────────────────────────────────────────────────┘
        "#]],
    );
}

#[test]
fn two_ops_same_parent_scope() {
    check(
        &[
            (&[("Main", 1), ("Foo", 2)], "H"),
            (&[("Main", 1), ("Foo", 3)], "X"),
        ],
        &expect![[r#"
                      ┌──── [Main] ────────────────────────────┐
                      │        ┌────── [Foo] ───────────┐      │
            q_0    ───┼────────┼──────── H ───── X ─────┼──────┼───
                      │        └────────────────────────┘      │
                      └────────────────────────────────────────┘
        "#]],
    );
}

#[test]
fn two_ops_separate_grandparents() {
    check(
        &[
            (&[("A", 1), ("B", 3), ("C", 4)], "X"),
            (&[("A", 2), ("B", 3), ("C", 4)], "X"),
        ],
        &expect![[r#"
                      ┌──── [A] ───────────────────────────────────────────────────────────────────┐
                      │      ┌──── [B] ──────────────────┐      ┌──── [B] ──────────────────┐      │
                      │      │      ┌──── [C] ────┐      │      │      ┌──── [C] ────┐      │      │
            q_0    ───┼──────┼──────┼───── X ─────┼──────┼──────┼──────┼───── X ─────┼──────┼──────┼───
                      │      │      └─────────────┘      │      │      └─────────────┘      │      │
                      │      └───────────────────────────┘      └───────────────────────────┘      │
                      └────────────────────────────────────────────────────────────────────────────┘
        "#]],
    );
}

#[test]
fn ad_hoc() {
    check(
        &[
            (&[("A", 1), ("B", 5), ("F", 9)], "X"),
            (&[("A", 1), ("B", 5), ("F", 10)], "Y"),
            (&[("A", 1), ("B", 5), ("F", 11)], "Z"),
            (&[("A", 2), ("B", 5), ("F", 9)], "X"),
            (&[("A", 2), ("B", 5), ("F", 10)], "Y"),
            (&[("A", 2), ("B", 5), ("F", 11)], "Z"),
            (&[("A", 2), ("B", 6), ("F", 10)], "Y"),
            (&[("A", 2), ("B", 6), ("F", 11)], "Z"),
            (&[("A", 1), ("B", 5), ("F", 9)], "X"),
            (&[("A", 1)], "Y"),
            (&[("A", 1)], "Z"),
            (&[("A", 2), ("B", 5), ("F", 10)], "Y"),
            (&[("A", 2), ("B", 5), ("F", 11)], "Z"),
            (&[("A", 3)], "C"),
            (&[("A", 4), ("D", 7)], "H"),
            (&[("A", 4), ("D", 8)], "I"),
            (&[("A", 5)], "E"),
            (&[("A", 5)], "G"),
        ],
        &expect![[r#"
                      ┌──── [A] ───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐
                      │      ┌──── [B] ────────────────────────────────┐      ┌──── [B] ────────────────────────────────────────────────────────────┐      ┌──── [B] ──────────────────┐                    ┌──── [B] ─────────────────────────┐             ┌──── [D] ───────────┐                    │
                      │      │      ┌──── [F] ──────────────────┐      │      │      ┌──── [F] ──────────────────┐      ┌──── [F] ───────────┐      │      │      ┌──── [F] ────┐      │                    │      ┌──── [F] ───────────┐      │             │                    │                    │
            q_0    ───┼──────┼──────┼───── X ──── Y ──── Z ─────┼──────┼──────┼──────┼───── X ──── Y ──── Z ─────┼──────┼───── Y ──── Z ─────┼──────┼──────┼──────┼───── X ─────┼──────┼───── Y ──── Z ─────┼──────┼───── Y ──── Z ─────┼──────┼───── C ─────┼───── H ──── I ─────┼───── E ──── G ─────┼───
                      │      │      └───────────────────────────┘      │      │      └───────────────────────────┘      └────────────────────┘      │      │      └─────────────┘      │                    │      └────────────────────┘      │             │                    │                    │
                      │      └─────────────────────────────────────────┘      └─────────────────────────────────────────────────────────────────────┘      └───────────────────────────┘                    └──────────────────────────────────┘             └────────────────────┘                    │
                      └────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘
        "#]],
    );
}
